#!/usr/bin/env python3
import argparse
import json
from pathlib import Path


def escape_cpp_string(value: str) -> str:
    out = []
    for ch in value:
        if ch == "\\":
            out.append("\\\\")
        elif ch == '"':
            out.append('\\"')
        elif ch == "\n":
            out.append("\\n")
        elif ch == "\r":
            out.append("\\r")
        elif ch == "\t":
            out.append("\\t")
        else:
            out.append(ch)
    return "".join(out)


def load_platforms(path: Path):
    data = json.loads(path.read_text(encoding="utf-8"))
    platforms = data.get("platforms")
    if not isinstance(platforms, list):
        raise ValueError("platforms must be a list")
    for entry in platforms:
        if not isinstance(entry, dict):
            raise ValueError("platform entry must be an object")
        if "key" not in entry or "id" not in entry:
            raise ValueError("platform entry requires key and id")
    detections = data.get("detections", [])
    if detections is None:
        detections = []
    if not isinstance(detections, list):
        raise ValueError("detections must be a list")
    return platforms, detections


def render_header(platforms, detections) -> str:
    platform_ids = {entry["key"]: entry["id"] for entry in platforms}
    lines = []
    lines.append("// Generated by tools/gen_platforms.py. Do not edit by hand.")
    lines.append("#pragma once")
    lines.append("")
    lines.append("#include <cstddef>")
    lines.append("#include <string>")
    lines.append("")
    lines.append("namespace sysutil {")
    lines.append("")
    for entry in platforms:
        key = entry["key"]
        pid = entry["id"]
        lines.append(f"static constexpr int {key} = {pid};")
    lines.append("")
    lines.append("struct PlatformTypeEntry {")
    lines.append("  int id;")
    lines.append("  const char* name;")
    lines.append("};")
    lines.append("")
    lines.append("inline constexpr PlatformTypeEntry kPlatformTypeEntries[] = {")
    for entry in platforms:
        display = entry.get("display")
        if display is None:
            continue
        pid = entry["id"]
        escaped = escape_cpp_string(display)
        lines.append(f'  {{{pid}, "{escaped}"}},')
    lines.append("};")
    lines.append("")
    lines.append("inline std::string platform_type_to_string(int platform_type) {")
    lines.append("  for (const auto& entry : kPlatformTypeEntries) {")
    lines.append("    if (entry.id == platform_type) {")
    lines.append("      return entry.name;")
    lines.append("    }")
    lines.append("  }")
    lines.append('  return "ERR-UNDEFINED{" + std::to_string(platform_type) + "}";')
    lines.append("}")
    lines.append("")
    if detections:
        lines.append("enum class ConditionKind {")
        lines.append("  FileExists,")
        lines.append("  FileContainsAny,")
        lines.append("  FileRegex,")
        lines.append("  ArchRegex,")
        lines.append("};")
        lines.append("")
        lines.append("struct DetectionCondition {")
        lines.append("  ConditionKind kind;")
        lines.append("  const char* path;")
        lines.append("  const char* pattern;")
        lines.append("  const char* group_equals;")
        lines.append("  const char* const* values;")
        lines.append("  std::size_t value_count;")
        lines.append("  bool case_insensitive;")
        lines.append("};")
        lines.append("")
        lines.append("struct DetectionRule {")
        lines.append("  int platform_id;")
        lines.append("  const DetectionCondition* conditions;")
        lines.append("  std::size_t condition_count;")
        lines.append("  const char* log;")
        lines.append("};")
        lines.append("")

        for rule_index, rule in enumerate(detections):
            if not isinstance(rule, dict):
                raise ValueError("detection rule must be an object")
            platform_key = rule.get("platform")
            if platform_key not in platform_ids:
                raise ValueError(f"unknown platform key in detection: {platform_key}")
            conditions = rule.get("conditions")
            if not isinstance(conditions, list) or not conditions:
                raise ValueError(f"detection rule for {platform_key} requires conditions")

            for cond_index, condition in enumerate(conditions):
                if not isinstance(condition, dict):
                    raise ValueError("detection condition must be an object")
                cond_type = condition.get("type")
                values = condition.get("values")
                if cond_type == "file_contains_any":
                    if not isinstance(values, list) or not values:
                        raise ValueError("file_contains_any requires values list")
                    value_items = ", ".join(
                        f'"{escape_cpp_string(v)}"' for v in values
                    )
                    lines.append(
                        f"inline constexpr const char* kRule{rule_index}Cond{cond_index}Values[] = {{{value_items}}};"
                    )

            lines.append("")
            lines.append(
                f"inline constexpr DetectionCondition kRule{rule_index}Conditions[] = {{"
            )
            for cond_index, condition in enumerate(conditions):
                cond_type = condition.get("type")
                case_insensitive = bool(condition.get("case_insensitive", False))
                path = condition.get("path")
                pattern = condition.get("pattern")
                group_equals = condition.get("group_equals")

                if cond_type == "file_exists":
                    if not path:
                        raise ValueError("file_exists requires path")
                    lines.append(
                        f'  {{ConditionKind::FileExists, "{escape_cpp_string(path)}", nullptr, nullptr, nullptr, 0, false}},'
                    )
                elif cond_type == "file_contains_any":
                    if not path:
                        raise ValueError("file_contains_any requires path")
                    values_name = f"kRule{rule_index}Cond{cond_index}Values"
                    value_count = len(condition["values"])
                    lines.append(
                        f'  {{ConditionKind::FileContainsAny, "{escape_cpp_string(path)}", nullptr, nullptr, {values_name}, {value_count}, {str(case_insensitive).lower()}}},'
                    )
                elif cond_type == "file_regex":
                    if not path or not pattern:
                        raise ValueError("file_regex requires path and pattern")
                    group_expr = "nullptr"
                    if group_equals:
                        group_expr = f'"{escape_cpp_string(group_equals)}"'
                    lines.append(
                        f'  {{ConditionKind::FileRegex, "{escape_cpp_string(path)}", "{escape_cpp_string(pattern)}", {group_expr}, nullptr, 0, {str(case_insensitive).lower()}}},'
                    )
                elif cond_type == "arch_regex":
                    if not pattern:
                        raise ValueError("arch_regex requires pattern")
                    lines.append(
                        f'  {{ConditionKind::ArchRegex, nullptr, "{escape_cpp_string(pattern)}", nullptr, nullptr, 0, {str(case_insensitive).lower()}}},'
                    )
                else:
                    raise ValueError(f"unknown detection condition type: {cond_type}")
            lines.append("};")
            lines.append("")

        lines.append("inline constexpr DetectionRule kDetectionRules[] = {")
        for rule_index, rule in enumerate(detections):
            platform_key = rule["platform"]
            platform_id = platform_ids[platform_key]
            log_value = rule.get("log", "")
            log_expr = f'"{escape_cpp_string(log_value)}"' if log_value else '""'
            lines.append(
                f"  {{{platform_id}, kRule{rule_index}Conditions, sizeof(kRule{rule_index}Conditions) / sizeof(kRule{rule_index}Conditions[0]), {log_expr}}},"
            )
        lines.append("};")
        lines.append("")
    lines.append("}  // namespace sysutil")
    lines.append("")
    return "\n".join(lines)


def main() -> int:
    parser = argparse.ArgumentParser()
    parser.add_argument("--input", required=True)
    parser.add_argument("--output", required=True)
    args = parser.parse_args()

    platforms, detections = load_platforms(Path(args.input))
    header = render_header(platforms, detections)
    Path(args.output).write_text(header, encoding="utf-8")
    return 0


if __name__ == "__main__":
    raise SystemExit(main())
